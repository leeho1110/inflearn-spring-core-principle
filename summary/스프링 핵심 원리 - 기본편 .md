# 스프링 핵심 원리 - 기본편

### 스프링은 어떻게 태어났을까?

- 원래는 자바 엔터프라이즈 애플리케이션를 EJB로 개발했다.
    - 당시 컨테이너 기술, 트랜잭션, 분산 서비스 등 다양한 기술들을 지원했다.
    - 하지만 느리고 복잡했다.
    - 이렇기 때문에 ‘단순함'을 추구하기 위해서 등장한 것이 POJO(Plain Old Java Object) 였다.
- 이를 대체하기 위해 로드 존슨이 ‘J2EE Design and Development’ 라는 스프링의 기반이 되는 서적을 발간했다.
    - 유겐 휠러와 얀 카로프가 로드 존슨에게 오픈 소스 프로젝트를 제안하며 ‘스프링 프로젝트'가 탄생
    - 스프링의 이름은 겨울을 넘어 새로운 시작이라는 뜻으로 작명

---

### 스프링이 제공하는 기능

- 핵심 기술
    - 스프링 DI 컨테이너
    - AOP
    - 이벤트
- 웹 기술
    - 스프링 MVC
    - 스프링 WebFlux
- 데이터 접근 기술
    - 트랜잭션
    - JDBC
    - ORM
- 최근엔 스프링 부트를 통해 스프링 프레임워크의 여러 기술들을 편리하게 사용할 수 있게 발전했다.
    - 단독 실행이 가능한 애플리케이션을 쉽고 빠르게 생성
        - 웹 서버 내장
        - 일반적으로 필요한 라이브러리를 미리 starter로 묶어 종속성을 제공
    - 스프링과 외부 라이브러리와의 의존성을 자동으로 매핑
    - 관례에 의한 편리한 설정

---

### 관심사의 분리

- 객체는 각자의 책임을 갖고 본인의 역할에만 집중해야 한다.
    - 배우들의 역할 예시를 언급하며 객체지향의 본질적인 개념을 전달
    - 외부(클라이언트)에서 의존성을 주입해주는 예시(AppConfig)를 통해 **Dependency Injection**을 스프링 컨테이너없이 구현
        - 생성자를 통해 외부에서 자신에게 필요한 객체를 주입해준다. 즉 어떤 객체가 들어올 지 알 수 없다.
    - 이를 통해 자신이 사용할 객체를 생성하고 사용하는 (객체의 의존 관계를 설정하는) 책임을 외부로 위임해버린다.
        - 이것이 바로 **제어의 역전, Inversion of Control**.

---

### 제어의 역전

- 최초 구현한 예제에서는 클라이언트 객체가 스스로 서버 객체를 생성, 연결, 실행하는 흐름을 가졌다. 즉 객체가 프로그램의 제어권의 주체였다.
    - 우리는 여기서 AppConfig를 통해 객체를 주입해주며 흐름을 뒤바꿨다.
    - 이렇게 프로그램의 제어 흐름을 직접 제어하지 않고 외부에서 관리하는 것이 **제어의 역전**이다.
    - 제어의 역전은 프레임워크와 라이브러리를 구분해주는 개념이기도 하다.
        - 토비의 스프링 3.1 Part1에서도 언급되는 내용이다.
        - 위에서 언급한 흐름의 제어권이 나에게 있지 않고, 프레임워크가 갖고 있다면 프레임워크다. 예를 들어 JUnit, Spring Core 등이 있다.
        - 반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니라 라이브러리다.

---

### 의존 관계 주입

- 우선 의존관계는 컴파일 타임 시점과 런타임 시점, 두 가지로 나눠진다.
    - 컴파일 타임 시점에는 코드 상에서 존재하는 의존성이다. 즉 애플리케이션을 실행시키기 전 객체들이 어떤 객체들을 의존하고 있는지에 대한 내용이다.
    - 하지만 AppConfig처럼 외부에서 구체 클래스를 외부에서 주입해주고 주입해주는 객체의 타입이 인터페이스라면 코드 상에서는 의존관계를 확정할 수 없다.
    - 즉 애플리케이션이 실행되어서 외부에서 설정 정보에 대한 책임을 갖고 제어하는 시점인 런타임 시점에 AppConfig처럼 외부에서 *의존성을 주입* 해주는 것을 **의존관계 주입, DI(Dependency Injection)** 이라고 한다.
        - 클라이언트 객체와 서버 객체의 실제 의존 관계는 런타임에 연결된다.
        - 이를 통해 우리는 객체간의 의존 관계를 런타임에서 유연하게 가져갈 수 있다.

---

### 스프링 컨테이너

- 스프링은 아까 AppConfig처럼 외부에서 객체의 의존성을 주입해주는 컨테이너를 제공한다. 이를 우리는 스프링 컨테이너라고 한다.
    - 컨테이너는 여러 방법으로 생성이 가능하다. 대표적으로는 XML 기반, 어노테이션 기반이 존재한다.
        - `ApplicationContext` 인터페이스를 상속하는 구현체를 통해 생성이 가능하다.
        - `GenericXmlApplicationContext` 구현체를 통해 XML 기반으로 생성
        - `AnnotationConfigApplicationContext` 구현체를 통해 어노테이션 기반으로 생성
    - 좀더 정확히는 BeanFactory와 ApplicationContext를 구분해서 이야기한다.
        
        <p align="center"><img src="applicationContext.png"></p>
        
        - ApplicationContext는 BeanFactory의 구현체다. BeanFactory의 모든 메서드를 상속받는다.
        - 이를 굳이 ApplicationContext로 상속받아서 사용하는 이유는 단순한 빈 관련 기능 말고도 추가적인 기능들을 확장하기 위해서다.
- 스프링은 @Configuration(설정정보 역할) 어노테이션이 붙은 클래스를 찾고 이를 **설정 정보**로 참조한다. 스프링은 이 클래스를 참고해 스프링 컨테이너에 빈 객체를 등록한다.
    - @Bean 어노테이션이 붙은 메서드를 호출해 반환된 객체를 컨테이너에 등록해준다.
        - 이렇게 등록된 객체를 **빈 객체** 라고 한다.
        - 빈 객체는 기본적으로 싱글톤 타입으로 생성된다.
    - 예전에는 빈 객체의 이름이 같을 경우 오버라이트 됐지만, 현재 스프링부트에서는 빈 이름이 중복돼 충돌이 발생하는 경우 예외를 발생시킨다.
        
        → *`org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: Bean name 'userDao' is already used in this <beans> element`*
        
    - 만약 없는 경우에도 예외를 발생시킨다.
        
        → *`org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'test' available`*
        
- 스프링은 어떻게 설정정보의 종류에 상관없이 빈을 등록할 수 있는 것일까?
    
            <p align="center"><img src="beanDefReader.png"></p>
    
    - 그 이유는 `BeanDefinition` 이다.
        - 스프링 컨테이너는 어노테이션 기반이던 XML 기반이던 상관하지 않고 BeanDefinition을 등록할 수 있다.

---

### 싱글톤 컨테이너 (토비의 스프링 Part 1 참조)

- 스프링은 웹 애플리케이션을 타겟으로 탄생했다. 물론 일반적인 애플리케이션 개발도 가능하지만 타겟층 자체가 주로 서버 환경의 웹 애플리케이션이었다.
    - 서버 환경에서는 1초에 수만개의 요청이 몰릴 수 있기에 이 때마다 객체를 생성해서 요청을 처리하는건 굉장한 메모리 낭비를 유발하기 때문에 장애에 발생할 가능성이 높아진다.
        - 이 때문에 엔터프라이즈 분야에서는 ‘서비스 오브젝트'라는 개념을 일찍부터 사용해왔다.
        - 그리고 서비스 오브젝트는 싱글톤으로 만들어 멀티 스레드 환경에서 동작한다.
    - 하지만 일반적인 싱글톤 패턴은 다음과 같은 한계를 갖는다.
        1. private 생성자로 인한 상속 불가, static field & method의 사용으로 인해 객체지향의 장점의 적용이 어렵다.
        2. 생성 방식이 제한적이기 때문에 테스트하기가 어렵다.
        3. 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다. 
            
            → 여러 개의 JVM에 분산되어 설치되는 경우 클래스 로더의 구성에 따라 클래스가 하나임에도 하나 이상의 오브젝트가 만들어질 수 있다.
            
        4. 싱글톤은 누구나 사용할 수 있다. 클라이언트가 지정되있지 않다는 의미다. 
            
            → 따라서 전역 상태로 사용되기 쉽고, 이는 접근,수정,공유가 자유롭다는 의미다. 이는 권장되지 않는다.
            
- 따라서 스프링은 자바의 기본적인 싱글톤 패턴 구현방식의 한계때문에 직접 싱글톤 형태의 오브젝트를 만들고 관리한다.
    - 이것이 바로 **싱글톤 레지스트리**이다.
    - 이는 위에서 말한 스태틱 메서드, private 생성자를 사용해 비정상적인 싱글톤 객체가 탄생하지 않도록 만들어준다.
        - public으로 만들어도 전혀 상관이 없다.
    - 싱글톤은 멀티스레드 환경에서 상태 관리에 주의해야 한다. 따라서 상태 정보를 내부에 갖고 있지 않는 무상태 stateless 방식으로 만들어져야 한다.
        - 여러 쓰레드에서 접근해 쓰기를 할 수 있는 인스턴스 변수 필드를 가져선 안된다.
        - 다만 만약 인스턴스 변수가 읽기 전용 정보로 쓰이고, 자신이 사용하는 다른 싱글톤 빈을 저장하려는 용도라면 사용해도 괜찮다. 어차피 스프링에서 관리하는 싱글톤 빈은 오브젝트 한개만 만들어질테니.
        - 읽기 전용이라면 static final, final로 선언하는 편이 낫다.
    - 스프링은 이렇게 만들어진 싱글톤 오브젝트를 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지시킨다.
        - 이렇게 빈이 생성되어 유지되고 적용되는 범위를 빈 스코프라고 한다.
        - 기본 스코프는 싱글톤이며, 이 외에는 프로토타입 prototype, 요청 request, 세션 session 스코프가 존재한다
- 스프링이 싱글톤을 구현하는 마법
    - 스프링은 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 클래스의 바이트코드를 조작한다.
    - @Configuration 을 붙이면 바이트코드를 조작하는 CGLIB 기술을 사용해서 싱글톤을 보장하wlaks @Bean만 붙인 경우 실제 객체를 등록한다는 것에 주의하자.

---

### 컴포넌트 스캔

- 빈 객체가 늘어나면 반복되는 XML 설정과 누락의 위험이 있다. 이를 자동화하기 위해 나온 것인 **컴포넌트 스캔** 기능이 등장했다.
    - @ComponentScan, @Autowired를 통해 @Component가 매핑된 클래스를 빈 객체로 등록해주고, 만약 컴포넌트 클래스에 빈 객체 주입까지 진행해준다.
    - @ComponetScan의 basePackages 애트리뷰트를 통해 컴포넌트 스캔의 범위 지정이 가능하다.
        - 만약 위 속성이 없는 경우 기본적으로 설정 정보 클래스가 위치한 패키지가 시작 위치로 지정된다.
        - 김영한님은 패키지 위치를 지정하지 않고, 설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것을 권장한다.
        - 최근 스프링 부트도 이 방법을 기본으로 제공한다. 스프링 부트를 사용하면 스프링 부트의 대표 시작 정보인 @SpringBootApplication 를 프로젝트 시작 루트 위치에 두는 것이 관례이다. 그리고 이 설정안에 @ComponentScan이 들어있다.
            
           <p align="center"><img src="CompentScan.png"></p>
            
- 컴포넌트 스캔은 @Component가 매핑된 클래스를 빈 객체로 등록해준다고 했다. 그런데 @Controller, @Service, @Repository는 어떻게 등록되는 것일까?
    - 어노테이션들이 내부에 @Component 어노테이션을 갖고 있는 것을 확인할 수 있다.
    - 그렇다면 이렇게 나눠놓은 이유는 무엇일까? 바로 각 계층의 특수성에 맞게 별도의 기능을 지원해주기 위함이다.
        - @Controller : 스프링 MVC 컨트롤러로 인식
        - @Repository : 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다.
        - @Configuration : 앞서 보았듯이 스프링 설정 정보로 인식하고, 스프링 빈이 싱글톤을 유지하도록 추가 처리를 한다.
        - @Service : 사실 @Service 는 특별한 처리를 하지 않는다. 대신 개발자들이 핵심 비즈니스 로직이 여기에 있겠구나 라고 비즈니스 계층을 인식하는데 도움이 된다.
- 컴포넌트 스캔 중 빈 이름의 중복이 발생하면 어떻게 될까?
    - 자동 빈 등록끼리의 병목에서는 `ConflictingBeanDefinitionException` 예외가 발생한다.
    - 수동과 자동 빈 등록 사이에서는 수동 빈 등록이 우선권을 가지고 자동 빈을 오버라이딩한다.
        - 이런 버그는 발견하지 힘들다.
        - 따라서 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류가 발생하도록 기본 값을 바꾸었다.

---

### 의존 관계 주입

- 스프링 컨테이너를 통해 의존관계를 주입하는 것에는 총 4가지가있다. 미리 말하자면 무조건 **생성자 주입**을 사용해라.
    - 생성자 호출시점에 딱 1번만 호출되는 것이 보장되며, **불변, 필수** 의존관계에 사용된다.
    - 생성자 주입을 통해 얻을 수 있는 장점이 무려 4가지나 있다.
        1. **객체의 불변을 보장한다.**
            
            → 서비스 오브젝트의 변경은 대부분의 경우 일어나지 않는다. 생성자에서 최초 객체 주입 후 혹시라도 모를 변경 가능성을 0%로 제한하는 것이 좋다.
            
        2. **테스트 코드 작성 시 스프링 컨테이너 없이 객체 주입 가능**
            
            → 만약 수정자 혹은 필드 주입인 경우 스프링 의존성 없이 객체를 주입할 수 없기 때문에 순수 자바 코드로 테스트를 작성하는 것이 어렵다. 하지만 생성자 주입의 경우 컴파일 타임(인스턴스 생성) 시점에 주입이 가능하다.
            
        3. ****final & Lombok + Spring Boot without @Autowired****
            
            → final 선언을 통해 컴파일 시점에 객체 의존성 체크가 가능하다. 또한 롬복의 `@RequiredArgsConstructor` 와 (생성자가 하나만 존재할 경우) 스프링부트가 @AutoWired 없이도 자동으로 의존성을 주입해주는 기능을 결합해 쉽게 의존성을 주입할 수 있다.
            
        4. **순환 참조 방지 가능**
            
            → 필드 주입의 경우 애플리케이션 구동 후 순환 참조 이슈가 존재하는 빈 객체의 메서드 호출 시 StackOverflow 예외가 발생한다. 생성자 주입으로 위 에러를 방지할 수 있다. 물론 스프링부트 2.6버전에서는 순환 참조가 허용되지 않는다. 
            
            > **Circular References Prohibited by Default**
            
            Circular references between beans are now prohibited by default. If your application fails to start due to a `BeanCurrentlyInCreationException` you are strongly encouraged to update your configuration to break the dependency cycle. If you are unable to do so, circular references can be allowed again by setting `spring.main.allow-circular-references` to `true`, or using the new setter methods on `SpringApplication` and `SpringApplicationBuilder` This will restore 2.5’s behaviour and automatically attempt to break the dependency cycle.
            > 
    

---

### 빈 생명주기

- 스프링 빈은 **객체 생성 → 의존관계 주입** 라이프사이클을 가진다.
    - 즉 객체를 생성과 의존관계 주입이 모두 완료된 후에 필요한 데이터를 사용할 수 있는 준비가 완료되는 것이다.
    - 따라서 초기화 작업은 의존관계 주입이 모두 완료되고 난 다음에 호출해야 한다. 하지만 우리가 과연 의존관계 주입이 모두 완료된 시점을 알 수 있을까?
        - 스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공한다.
        - 또한 **스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백**을 준다. 따라서 안전하게 종료 작업을 진행할 수 있다.
    - 스프링 빈의 이벤트 라이프사이클은 아래와 같다.
        - **스프링 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 사용 → 소멸 전 콜백 → 스프링 종료**

---

### 참고자료

- [https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.6-Release-Notes#circular-references-prohibited-by-default](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.6-Release-Notes#circular-references-prohibited-by-default)