**좋은 객체 지향 설계의 5가지 원칙**

이 중 3가지 SRP, DIP, OCP를 적용시켜보자.

1. SRP (단일 책임 원칙) : 한 클래스는 하나의 책임만 가져야 한다.
   기존 클라이언트 객체는 직접 구현 객체를 생성, 연결, 실행하는 다양한 책임을 갖고 있었다.
   따라서 우리는 **구현 객체를 생성, 연결하는 책임**은 AppConfig가 담당하게 하고 클라이언트 객체는 **실행**만 하도록 관심사를 분리했다.

2. DIP (의존관계 역전 원칙) : 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다" , 의존성 주입은 이 원칙을 따르는 방법 중 하나다. 
    할인 정책을 추가하고 적용하려 했더니, 클라이언트 코드(OrderService)도 변경해야 했다. DiscountPolicy 필드에 인터페이스를 추가헤 추상화 인터페이스에
    의존하는 것 같았지만 **결국은 클라이언트 코드에서 해당 필드에 구현체를 넣어주며 구체화 구현 클래스까지도 의존한 상태**였다.

    따라서 우리는 클라이언트 코드가 DiscountPolicy 필드에 구현체를 직접 넣어주지 않고,  
    AppConfig를 통해 객체를 생성하여 의존관계를 주입해 DIP원칙을 따르도록 변경했다.

3. OCP : 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
    
   다형성을 사용하고, 클라이언트가 DIP를 지킨다. 애플리케이션을 사용 영역과 구성 영역으로 나눠서
   AppConfig가 의존관계를 각 상황에 맞춰 클라이언트 코드에 주입해주므로 클라이언트 코드는 변경하지 않았다.

   즉 소프트웨어 요소를 새롭게 확장해도(할인 정책을 추가해도) 사용 영역의 클라이언트 코드는 변하지 않았으므로 OCP 원칙까지 지킬 수 있었다.

---

**IoC 컨테이너, DI 컨테이너 : 의존관계 주입 (Dependency Injection)**

AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 **IoC 컨테이너 or DI 컨테이너** 라고 한다.AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 것을 **IoC 컨테이너 or DI 컨테이너** 라고 한다.

---

**BeanFactory, ApplicationContext**

1. BeanFactory
   - 스프링 컨테이너의 최상위 인터페이스이다.
   - 스프링 빈을 관리하고 조회하는 역할을 담당한다.

2. ApplicationContext
   - BeanFactory의 기능을 모두 상속받아 제공한다.
   - 애플리케이션을 개발할 때는 빈의 관리 조회 기능말고도 필요한 부가기능들을 제공한다.
   - 부가기능
      1. MessageSource 
         한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력
      2. EnvironmentCapable
         로컬, 개발, 운영 등을 구분해서 처리
      3. ApplicationEventPublisher
         이벤트를 발행하고 구독하는 모델을 편리하게 지원
      4. ResourceLoader
         파일, 클래스 패스, 외부 등에서 리소스를 편리하게 조회
